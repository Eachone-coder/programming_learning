# PHP学习

- [ ] 手册阅读
- [ ] MySQL数据库
- [ ] Redis缓存
- [ ] Linux基础
- [ ] Linux高级
- [ ] Laravel
- [ ] Yii2
- [ ] 正则表达式
- [ ] 计算机基础知识
- [ ] Markdown语法
- [ ] Vue
- [ ] Flex布局
- [ ] 小程序

## 手册阅读

### PHP 支持 9 种原始数据类型¶

#### 四种标量类型

boolean（布尔型）
integer（整型）
float（浮点型，也称作 double)
string（字符串）

#### 三种复合类型

array（数组）
object（对象）
callable（可调用）

#### 两种特殊类型

resource（资源）
NULL（无类型）

为了确保代码的易读性，还有一些伪类型：
mixed（混合类型）
number（数字类型）
callback（回调类型，又称为 callable）
array|object（数组 | 对象类型）
void （无类型）
以及伪变量 $...。

------

### Boolean 布尔类型 ¶

#### 转换为布尔值 ¶

以下值被认为是 **FALSE**：

- 布尔值 **FALSE** 本身
- 整型值 0（零）
- 浮点型值 0.0（零）
- 空字符串，以及字符串"0"
- 不包括任何元素的数组
- 特殊类型 NULL（包括尚未赋值的变量）
- 从空标记生成的 SimpleXML 对象

所有其它值都被认为是 **TRUE**（包括任何资源 和 **NAN**），*-1* 和其它非零值（不论正负）一样，被认为是 **TRUE**！

```php
var_dump(0 == 'all'); // true,
var_dump(0 === 'all'); // false
```

------

### Integer 整型 ¶

整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。

二进制表达的 integer自 PHP 5.4.0 起可用。

要使用八进制表达，数字前必须加上 *0*（零）。要使用十六进制表达，数字前必须加上 *0x*。要使用二进制表达，数字前必须加上 *0b*。

`integer` 语法的结构形式是：

```php
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

binary      : 0b[01]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
            | [+-]?binary
```

整型数的字长和平台有关，最大值可以用常量 **PHP_INT_MAX** 来表示，最小值可以在 PHP 7.0.0 及以后的版本中用常量 **PHP_INT_MIN** 表示。

PHP 不支持无符号的 integer

PHP 7 以前的版本里，如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。PHP 7 以后，会产生 Parse Error。

#### 整数溢出 ¶

如果给定的一个数超出了 `integer` 的范围，将会被解释为 `float`。同样如果执行的运算结果超出了 `integer` 范围，也会返回 `float`。

#### 转换为整型 ¶

- `resource`转换成 `integer`时， 结果会是 PHP 运行时为 `resource`分配的唯一资源号。
- **FALSE** 将产生出 *0*（零），**TRUE** 将产生出 *1*（壹）。
- 当从浮点数转换成整数时，将*向下*取整。如果浮点数超出了整数范围，则结果为未定义，因为没有足够的精度给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
- PHP 7.0.0 起，`NaN` 和 `Infinity` 在转换成 `integer` 时，不再是 `undefined` 或者依赖于平台，而是都会变成零。

------

### Float 浮点型 ¶

浮点型（也叫浮点数 float，双精度数 double 或实数 real）可以用以下任一语法定义：

```php
<?php$a = 1.234; $b = 1.2e3; $c = 7E-10;?>
```

浮点数的形式表示：

```php
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
```

浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。

所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。

#### 比较浮点数 ¶

由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。不过还是有迂回的方法来比较浮点数值的。

要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。

$a 和 $b 在小数点后五位精度内都是相等的。

```php
<?php
    $a = 1.23456789;
	$b = 1.23456780;
	$epsilon = 0.00001;
    if(abs($a-$b) < $epsilon) {    
        echo "true";
    }
?>
```

#### NaN ¶

某些数学运算会产生一个由常量 **NAN** 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了**TRUE**）进行的松散或严格比较的结果都是 **FALSE**。

由于 **NAN** 代表着任何不同值，不应拿 **NAN** 去和其它值进行比较，包括其自身，应该用 `is_nan()`来检查。

------
### String 字符串 ¶

#### 语法 ¶

一个字符串可以用 4 种方式表达：

- 单引号
- 双引号
- heredoc 语法结构
- nowdoc 语法结构（自 PHP 5.3.0 起）

##### 单引号 ¶

定义一个字符串的最简单的方法是用单引号把它包围起来（字符 *'*）。

要表达一个单引号自身，需在它的前面加个反斜线（*\*）来转义。要表达一个反斜线自身，则用两个反斜线（*\\*）。其它任何方式的反斜线都会被当成反斜线本身：也就是说如果想使用其它转义序列例如 *\r* 或者 *\n*，并不代表任何特殊含义，就单纯是这两个字符本身。

> **Note**: 不像双引号和 `heredoc`语法结构，在单引号字符串中的变量和特殊字符的转义序列将*不会*被替换。

##### 双引号 ¶

如果字符串是包围在双引号（"）中， PHP 将对一些特殊的字符进行解析：

| 序列                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| *\n*                 | 换行（ASCII 字符集中的 LF 或 0x0A (10)）                     |
| *\r*                 | 回车（ASCII 字符集中的 CR 或 0x0D (13)）                     |
| *\t*                 | 水平制表符（ASCII 字符集中的 HT 或 0x09 (9)）                |
| *\v*                 | 垂直制表符（ASCII 字符集中的 VT 或 0x0B (11)）（自 PHP 5.2.5 起） |
| *\e*                 | Escape（ASCII 字符集中的 ESC 或 0x1B (27)）（自 PHP 5.4.0 起） |
| *\f*                 | 换页（ASCII 字符集中的 FF 或 0x0C (12)）（自 PHP 5.2.5 起）  |
| *\\*                 | 反斜线                                                       |
| *\$*                 | 美元标记                                                     |
| *\"*                 | 双引号                                                       |
| *\[0-7]{1,3}*        | 符合该正则表达式序列的是一个以八进制方式来表达的字符         |
| *\x[0-9A-Fa-f]{1,2}* | 符合该正则表达式序列的是一个以十六进制方式来表达的字符       |

和单引号字符串一样，转义任何其它字符都会导致反斜线被显示出来。





#### 存取和修改字符串中的字符 ¶

`string` 中的字符可以通过一个从 0 开始的下标，用类似 `array` 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 `string` 当成字符组成的 `array`。函数 `substr()` 和 `substr_replace()` 可用于操作多于一个字符的情况。

> 用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个**E_NOTICE** 级别错误。用负数下标写入字符串时会产生一个 **E_NOTICE** 级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。

#### 有用的函数和运算符 ¶

字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符*没有*这个功能。更多信息参考字符串运算符。

对于 `string` 的操作有很多有用的函数。

可以参考`字符串函数`了解大部分函数，高级的查找与替换功能可以参考`正则表达式函数`或 `Perl 兼容正则表达式函数`。

另外还有 `URL 字符串函数`，也有加密／解密字符串的函数`mcrypt` 和 `mhash`

#### 有用的函数和运算符 ¶

- 一个布尔值 boolean 的 **TRUE** 被转换成 `string` 的 *"1"*。`Boolean` 的 **FALSE** 被转换成 *""*（空字符串）。这种转换可以在 `boolean` 和 `string` 之间相互进行。

- 一个整数 `integer` 或浮点数 `float` 被转换为数字的字面样式的 `string`（包括 `float` 中的指数部分）。使用指数计数法的浮点数（*4.1E+6*）也可转换。

> **Note**:
>
> 在脚本的区域（category LC_NUMERIC）中定义了十进制小数点字符。参见 `setlocale()`。

- 数组 `array` 总是转换成字符串 *"Array"*，因此，`echo` 和 `print` 无法显示出该数组的内容。要显示某个单元，可以用 *echo $arr['foo']* 这种结构。

- 在 PHP 4 中对象 `object`总是被转换成字符串 *"Object"*。为了得到对象的类的名称，可以用 `get_class()` 函数。自 PHP 5 起，适当时可以用 `__toString` 方法。

- 资源 `resource`总会被转变成 *"Resource id #1"* 这种结构的字符串，其中的 *1* 是 PHP 在运行时分配给该 `resource` 的唯一值。不要依赖此结构，可能会有变更。要得到一个 `resource`的类型，可以用函数 `get_resource_type()`。

- **NULL** 总是被转变成空字符串。

如上面所说的，直接把 `array`，`object` 或 `resource` 转换成 `string` 不会得到除了其类型之外的任何有用信息。可以使用函数 `print_r()` 和 `var_dump()`列出这些类型的内容。

大部分的 PHP 值可以转变成 `string` 来永久保存，这被称作串行化，可以用函数 `serialize()` 来实现。如果 PHP 引擎设定支持 `WDDX`，PHP 值也可被串行化为格式良好的 XML 文本。

### Array 数组 ¶

PHP 中的数组实际上是一个有序映射。映射是一种把 *values* 关联到 *keys* 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。



### 函数

#### 数组函数 ¶

- `usort ( array `&$array` , callable `$value_compare_func` ) : bool— 使用用户自定义的比较函数对数组中的值进行排序` 

```php
/**
     * 多维数组排序
     * @param array $arr
     * @param null $order
     * @return array
     *
     * 示例：
     * 输入：
     * $arr = [
     *      ['id'=>1, 'age'=>1, 'sex'=>6, 'name'=>'a'],
     *      ['id'=>2, 'age'=>3, 'sex'=>1, 'name'=>'c'],
     *      ['id'=>3, 'age'=>3, 'sex'=>1, 'name'=>'b'],
     *      ['id'=>4, 'age'=>2, 'sex'=>1, 'name'=>'d'],
     * ];
     * $order = 'age asc,sex asc,name desc'
     *
     * 输出：
     * $arr = [
     *      ['id'=>1, 'age'=>1, 'sex'=>6, 'name'=>'a'],
     *      ['id'=>4, 'age'=>2, 'sex'=>1, 'name'=>'d'],
     *      ['id'=>2, 'age'=>3, 'sex'=>1, 'name'=>'c'],
     *      ['id'=>3, 'age'=>3, 'sex'=>1, 'name'=>'b'],
     * ];
     *
     */
    function array_order_by(array &$arr, $order = null)
    {
        if (is_null($order)) {
            return $arr;
        }
        $orders = explode(',', $order);
        // 使用用户自定义的比较函数对数组中的值进行排序
        usort($arr, function ($a, $b) use ($orders) {
            $result = array();
            foreach ($orders as $value) {
                //分割    截取
                list($field, $sort) = array_map('trim', explode(' ', trim($value)));
                if (!(isset($a[$field]) && isset($b[$field]))) {
                    continue;
                }
                // 二进制安全比较字符串（不区分大小写）
                // 如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。
                if (strcasecmp($sort, 'desc') === 0) {
                    $tmp = $a;
                    $a = $b;
                    $b = $tmp;
                }

                if (is_numeric($a[$field]) && is_numeric($b[$field])) {
                    $result[] = $a[$field] - $b[$field];
                } else {
                    // 二进制安全字符串比较（区分大小写）
                    // 如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。
                    $result[] = strcmp($a[$field], $b[$field]);
                }
            }
            return implode('', $result);
        });
        return $arr;
    }
```

- `uksort ( array &$array , callable $key_compare_func ) : bool— 使用用户自定义的比较函数对数组中的键名进行排序`

> 参数

```php
$input
```



- `uasort ( array &$array , callable $value_compare_func ) : bool — 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联` 

> 参数

```php
$input
```



- `sort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool — 对数组排序  ▲`

> - **SORT_REGULAR** - 正常比较单元（不改变类型）
> - **SORT_NUMERIC** - 单元被作为数字来比较
> - **SORT_STRING** - 单元被作为字符串来比较
> - **SORT_LOCALE_STRING** - 根据当前的区域（locale）设置来把单元当作字符串比较，可以用 `setlocale()`来改变。
> - **SORT_NATURAL** - 和 `natsort()` 类似对每个单元以“自然的顺序”对字符串进行排序。 PHP 5.4.0 中新增的。
> - **SORT_FLAG_CASE** - 能够与 **SORT_STRING** 或 **SORT_NATURAL** 合并（OR 位运算），不区分大小写排序字符串。

```php
/**
     * 通过特定键对数组进行排序
     * @param array $array
     * @param string $on
     * @param int $order
     * @param bool $keep_key
     * @return array
     */
    function array_sort(array $array, $on = '', $order = SORT_ASC, $keep_key = true)
    {
        $new_array = array();
        $sortable_array = array();

        if (count($array) > 0) {
            foreach ($array as $k => $v) {
                if (is_array($v)) {
                    foreach ($v as $k2 => $v2) {
                        if ($k2 == $on) {
                            $sortable_array[$k] = $v2;
                        }
                    }
                } else {
                    $sortable_array[$k] = $v;
                }
            }

            switch ($order) {
                case SORT_ASC:
                    asort($sortable_array);
                    break;
                case SORT_DESC:
                    arsort($sortable_array);
                    break;
            }

            if ($keep_key) {
                foreach ($sortable_array as $k => $v) {
                    $new_array[$k] = $array[$k];
                }
            } else {
                foreach ($sortable_array as $k => $v) {
                    $new_array[] = $array[$k];
                }
            }

        }

        return $new_array;
    }
```

- `sizeof` — `count()`的别名
- `shuffle ( array &$array ) : bool — 打乱数组  ▲`

> 参数

```php
$input
```



- `rsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool— 对数组逆向排序` 

> 参数

```php
$input
```



- `reset ( array &$array ) : mixed — 将数组的内部指针指向第一个单元`

> 参数

```php
$input
```



- `range ( mixed $start , mixed $end [, number $step = 1 ] ) : array— 根据范围创建数组，包含指定的元素  ▲` 

> 参数

```php
$input
```



- `prev ( array &$array ) : mixed — 将数组的内部指针倒回一位`

> 参数

```php
$input
```



- `pos — current() 的别名`

> 参数

```php
$input
```



- `next ( array &$array ) : mixed — 将数组中的内部指针向前移动一位`

> 参数

```php
$input
```



- `natsort ( array `&$array` ) : bool — 用“自然排序”算法对数组排序` 

> 参数

```php
$input
```



- `natcasesort ( array &$array ) : bool — 用“自然排序”算法对数组进行不区分大小写字母的排序`

> 参数

```php
$input
```



- `list ( mixed $var1 [, mixed $... ] ) : array — 把数组中的值赋给一组变量  ▲` 

> 参数

```php
$input
```



- `ksort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool — 对数组按照键名排序`

> 参数

```php
$input
```



- `krsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool — 对数组按照键名逆向排序`

> 参数

```php
$input
```



- `key ( array $array ) : mixed — 从关联数组中取得键名`

> 参数

```php
$input
```



- `key_exists — 别名 array_key_exists()`

> 参数

```php
$input
```



- `in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool — 检查数组中是否存在某个值  ▲`

> 参数

```php
$input
```



- `extract ( array &$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]] ) : int — 从数组中将变量导入到当前的符号表`

> 参数

```php
$input
```



- `end ( array &$array ) : mixed — 将数组的内部指针指向最后一个单元`

> 参数

```php
$input
```



- `current ( array &$array ) : mixed — 返回数组中的当前单元`

> 参数

```php
$input
```



- `count ( mixed $array_or_countable [, int $mode = COUNT_NORMAL ] ) : int — 计算数组中的单元数目，或对象中的属性个数`

> 参数

```php
$input
```



- `compact ( mixed $varname1 [, mixed $... ] ) : array — 建立一个数组，包括变量名和它们的值`

> 参数

```php
$input
```



- `asort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool — 对数组进行排序并保持索引关系`

> 参数

```php
$input
```



- `arsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool — 对数组进行逆向排序并保持索引关系`

> 参数

```php
$input
```



- `array_walk ( array &$array , callable $callback [, mixed $userdata = NULL ] ) : bool — 使用用户自定义函数对数组中的每个元素做回调处理`

> 参数

```php
$input
```



- `array_walk_recursive ( array &$array , callable $callback [, mixed $userdata = NULL ] ) : bool — 对数组中的每个成员递归地应用用户函数`

> 参数

```php
$input
```



- `array_values ( array $array ) : array — 返回数组中所有的值`

> 参数

```php
$input
```



- `array_unshift ( array &$array [, mixed $... ] ) : int — 在数组开头插入一个或多个单元`

> 参数

```php
$input
```



- `array_unique ( array $array [, int $sort_flags = SORT_STRING ] ) : array — 移除数组中重复的值`

> 参数

```php
$input
```



- `array_uintersect ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array — 计算数组的交集，用回调函数比较数据`

> 参数

```php
$input
```



- `array_uintersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func , callable $key_compare_func ) : array — 带索引检查计算数组的交集，用单独的回调函数比较数据和索引`

> 参数

```php
$input
```



- `array_uintersect_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array — 带索引检查计算数组的交集，用回调函数比较数据`

> 参数

```php
$input
```



- `array_udiff ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array — 用回调函数比较数据来计算数组的差集`

> 参数

```php
$input
```



- `array_udiff_uassoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func , callable $key_compare_func ) : array — 带索引检查计算数组的差集，用回调函数比较数据和索引`

> 参数

```php
$input
```



- `array_udiff_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array — 带索引检查计算数组的差集，用回调函数比较数据`

> 参数

```php
$input
```



- `array_sum ( array $array ) : number — 对数组中所有值求和`

> 参数

```php
$input
```



- `array_splice ( array &$input , int $offset [, int $length = count($input) [, mixed $replacement = array() ]] ) : array — 去掉数组中的某一部分并用其它值取代`

> 参数

```php
$input
```



- `array_change_key_case ( array $array [, int $case = CASE_LOWER ] ) : array — 将数组中的所有键名修改为全大写或小写`

> ###### 参数
>
> `array`
>
> 需要操作的数组。
>
> `case`
>
> 可以在这里用两个常量，**CASE_UPPER** 或 **CASE_LOWER**（默认值）。
>
> ###### 返回值
>
> 返回一个键全是小写或者全是大写的数组；如果输入值（`array`）不是一个数组，那么返回**FALSE**
>
> ###### 注释
>
> 如果一个数组中的多个键名经过本函数后变成一样的话（例如 "*keY*" 和 "*kEY*"），最后一个值将覆盖其它的值。

```php
$input = ["FirSt" => 1, "SecOnd" => 4, "fiRST" => 2];
$news = array_change_key_case($input,CASE_LOWER);
//$news = ["first" => 2, "second" => 4];
```



- `array_chunk ( array $array , int $size [, bool $preserve_keys = false ] ) : array — 将一个数组分割成多个`

> ###### 参数
>
> `array`
>
> 需要操作的数组
>
> `size`
>
> 每个数组的单元数目
>
> `preserve_keys`
>
> 设为 **TRUE**，可以使 PHP 保留输入数组中原来的键名。如果你指定了 **FALSE**，那每个结果数组将用从零开始的新数字索引。默认值是 **FALSE**。
>
> ###### 返回值
>
> 得到的数组是一个多维数组中的单元，其索引从零开始，每一维包含了 `size` 个元素。
>
> ###### 注释
>
> 如果 `size` 小于 1，会抛出一个 **E_WARNING** 错误并返回 **NULL**。

```php
$input = ['a', 'b', 'c', 'd', 'e'];
array_chunk($input_array, 2)	//[['a', 'b'],['c', 'd'],['e']]
array_chunk($input_array, 2, true)
//[[0=>'a', 1=>'b'],[2=>'c', 3=>'d'],[4=>'e']]
```



- `array_column ( array $input , mixed $column_key [, mixed $index_key = null ] ) : array — 返回数组中指定的一列`

> ###### 参数
>
> `input`
>
> 需要取出数组列的多维数组。 如果提供的是包含一组对象的数组，只有 public 属性会被直接取出。 为了也能取出 private 和 protected 属性，类必须实现 **__get()** 和 **__isset()** 魔术方法。
>
> `column_key`
>
> 需要返回值的列，它可以是索引数组的列索引，或者是关联数组的列的键，也可以是属性名。 也可以是**NULL**，此时将返回整个数组（配合`index_key`参数来重置数组键的时候，非常管用）
>
> `index_key`
>
> 作为返回数组的索引/键的列，它可以是该列的整数索引，或者字符串键值。
>
> ###### 返回值
>
> 从多维数组中返回单列数组。

```php
$input = [
    [
     	'id' => 2135,
        'first_name' => 'John',
        'last_name' => 'Doe',   
    ],
    [
        'id' => 3245,
        'first_name' => 'Sally',
        'last_name' => 'Smith',
    ],
    [
        'id' => 5342,
        'first_name' => 'Jane',
        'last_name' => 'Jones',
    ],
    [
        'id' => 5623,
        'first_name' => 'Peter',
        'last_name' => 'Doe',
    ]
];

array_column($records, 'first_name');
//['John','Sally','Jane','Peter']
array_column($records, 'first_name','id');
//[2135=>'John',3245=>'Sally',5342=>'Jane',5623=>'Peter']
```



- `array_combine ( array $keys , array $values ) : array — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值`

> ###### 参数
>
> `keys`
>
> 将被作为新数组的键。非法的值将会被转换为字符串类型（string）。
>
> `values`
>
> 将被作为 Array 的值。
>
> ###### 返回值
>
> 返回合并的 array，如果两个数组的单元数不同则返回 **FALSE**。
>
> ###### 注释
>
> 如果作为`keys`的数组和作为`values`的数组的元素个数不一样，将会抛出一个警告错误（**E_WARNING**）。

```php
$a = ['green', 'red', 'yellow'];
$b = ['avocado', 'apple', 'banana'];
array_combine($a, $b);	
//['green'=>'avocado', 'red'=>'apple', 'yellow'=>'banana']

$c = ['a','a','b'];
$d = [1,2,3];
array_combine($c, $d);
//['a'=>2, 'b'=>3]
```



- `array_count_values ( array $array ) : array — 统计数组中所有的值`

> ###### 参数
>
> `input`
>
> 统计这个数组的值
>
> ###### 返回值
>
> 返回一个关联数组，用 `array` 数组中的值作为键名，该值在数组中出现的次数作为值。
>
> ###### 注释
>
> 对数组里面的每个不是 `string` 和 `integer` 类型的元素抛出一个警告错误（**E_WARNING**）。

```php
$input = [1, "hello", 1, "world", "hello"];
array_count_values($array);	// [1=>2,'hello'=>2,'world'=>1];
```



- `array_diff_assoc ( array $array1 , array $array2 [, array $... ] ) : array — 带索引检查计算数组的差集`

> ###### 参数
>
> `array1`
>
> 从这个数组进行比较
>
> `array2`
>
> 被比较的数组
>
> `...`
>
> 更多被比较的数组
>
> ###### 注释
>
> 注意本函数只检查了多维数组中的一维。当然可以用 *array_diff_assoc($array1[0], $array2[0]);* 检查更深的维度。
>
> 使用更多的键比较相似数组时，确保你传入参数的顺序是正确的。 新的数组应该是在列表里的第一个。

```php
$a = ["a" => "green", "b" => "brown", "c" => "blue", "red"];
$b = ["a" => "green", "yellow", "red"];
array_diff_assoc($a, $b);
// ["b" => "brown","c" => "blue"]
```



- `array_diff_key ( array $array1 , array $array2 [, array $... ] ) : array — 使用键名比较计算数组的差集`

> ###### 参数
>
> `array1`
>
> 从这个数组进行比较
>
> `array2`
>
> 针对此数组进行比较
>
> `...`
>
> 更多比较数组
>
> ###### 返回值
>
> `array_diff_key()` 返回一个数组，该数组包括了所有出现在 `array1` 中但是未出现在任何其它参数数组中的键名的值。
>
> ###### 注释
>
> 注意本函数只检查了多维数组中的一维。当然，可以用 *array_diff_key($array1[0], $array2[0]);* 来检查更深的维度。

```php
$a = ['blue'  => 1, 'red'  => 2, 'green'  => 3, 'purple' => 4];
$b = ['green' => 5, 'blue' => 6, 'yellow' => 7, 'cyan'   => 8];
array_diff_key($a, $b)	//	['red'  => 2,'purple' => 4]
```



- `array_diff_uassoc ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array — 用用户提供的回调函数做索引检查来计算数组的差集`

> ###### 参数
>
> `array1`
>
> 待比较的数组
>
> `array2`
>
> 和这个数组进行比较
>
> `...`
>
> 更多比较的数组
>
> `key_compare_func`
>
> 在第一个参数小于，等于或大于第二个参数时，该比较函数必须相应地返回一个小于，等于或大于 0 的整数。
>
> callback ( mixed `$a`, mixed `$b` ) : int
>
> ###### 返回值
>
> 返回一个 `array`，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。
>
> ###### 注释
>
> 

```php
$input
```



- `array_diff_ukey ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array — 用回调函数对键名比较计算数组的差集`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_diff ( array $array1 , array $array2 [, array $... ] ) : array — 计算数组的差集`

> ###### 参数
>
> `array1`
>
> 要被对比的数组
>
> `array2`
>
> 和这个数组进行比较
>
> `...`
>
> 更多相比较的数组
>
> ###### 返回值
>
> 返回一个数组，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。注意键名保留不变。
>
> ###### 注释
>
> 

```php
$input
```



- `array_fill_keys ( array $keys , mixed $value ) : array — 使用指定的键和值填充数组`

> ###### 参数
>
> `keys`
>
> 使用该数组的值作为键。非法值将被转换为字符串。
>
> `value`
>
> 填充使用的值。
>
> ###### 返回值
>
> 返回填充后的数组。
>
> ###### 注释
>
> 

```php
$input
```



- `array_fill ( int $start_index , int $num , mixed $value ) : array — 用给定的值填充数组`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array — 用回调函数过滤数组中的单元`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_flip ( array $array ) : array— 交换数组中的键和值`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_intersect_assoc ( array $array1 , array $array2 [, array $... ] ) : array — 带索引检查计算数组的交集`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_intersect_key ( array $array1 , array $array2 [, array $... ] ) : array — 使用键名比较计算数组的交集`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_intersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array — 带索引检查计算数组的交集，用回调函数比较索引`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_intersect_ukey ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array — 用回调函数比较键名来计算数组的交集`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_intersect ( array $array1 , array $array2 [, array $... ] ) : array— 计算数组的交集`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_key_exists ( mixed $key , array $array ) : bool — 检查数组里是否有指定的键名或索引`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_key_first ( array $array ) : mixed — Gets the first key of an array`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_key_last ( array $array ) : mixed — Gets the last key of an array`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_keys ( array $array [, mixed $search_value = null [, bool $strict = false ]] ) : array — 返回数组中部分的或所有的键名`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_map ( callable $callback , array $array1 [, array $... ] ) : array — 为数组的每个元素应用回调函数`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_merge_recursive ( array $array1 [, array $... ] ) : array — 递归地合并一个或多个数组`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_merge ( array $array1 [, array $... ] ) : array — 合并一个或多个数组`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_multisort ( array &$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $... ]]] ) : bool — 对多个数组或多维数组进行排序`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_pad ( array $array , int $size , mixed $value ) : array — 以指定长度将一个值填充进数组`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_pop ( array &$array ) : mixed — 弹出数组最后一个单元（出栈）`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_product ( array $array ) : number — 计算数组中所有值的乘积`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_push ( array &$array , mixed $value1 [, mixed $... ] ) : int — 将一个或多个单元压入数组的末尾（入栈）`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_rand ( array $array [, int $num = 1 ] ) : mixed — 从数组中随机取出一个或多个单元`

> ###### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php
$input
```



- `array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed — 用回调函数迭代地将数组简化为单一的值`

> ###### 参数
>
> `array`
>
> 输入的 array。
>
> `callback`
>
> callback ( [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) `$carry` , [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) `$item` ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed)
>
> - `carry`
>
>   携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 `initial`。
>
> - `item`
>
>   携带了本次迭代的值。
>
> `initial`
>
> 如果指定了可选参数 `initial`，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。

```php
$input
```



- `array_replace_recursive ( array $array1 [, array $... ] ) : array — 使用传递的数组递归替换第一个数组的元素`

> ###### 参数
>
> `array1`
>
> 替换该数组的值。
>
> `...`
>
> 可选项。包含要提取元素的数组。

```php
$input
```



- `array_replace ( array $array1 [, array $... ] ) : array — 使用传递的数组替换第一个数组的元素`

> ###### 参数
>
> `array1`
>
> 替换该数组的值。
>
> `...`
>
> 包含要提取元素的数组。 后面的数组里的值会覆盖前面的值。

```php
$input = ["orange", "banana", "apple", "raspberry"];
$replacements = [0 => "pineapple", 4 => "cherry"];
$replacements2 = [0 => "grape"];

$basket = array_replace($base, $replacements, $replacements2);
//["grape", "banana", "apple", "raspberry", "cherry"];
```



- `array_reverse ( array $array [, bool $preserve_keys = FALSE ] ) : array — 返回单元顺序相反的数组`

> ###### 参数
>
> `array`
>
> 输入的数组。
>
> `preserve_keys`
>
> 如果设置为 **TRUE** 会保留数字的键。 非数字的键则不受这个设置的影响，总是会被保留。

```php
$input  = ["php", 4.0, ["green", "red"]];
$reversed = array_reverse($input);	//[ ["green", "red"],4,"php"]
$preserved = array_reverse($input, true);//[ 2=>["green", "red"],1=>4,2=>"php"]
```



- `array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) : mixed— 在数组中搜索给定的值，如果成功则返回首个相应的键名`

> ###### 参数
>
> `needle`
>
> 搜索的值。
>
> > **Note**:
> >
> > 如果 `needle` 是字符串，则比较以区分大小写的方式进行。
>
> `haystack`
>
> 这个数组。
>
> `strict`
>
> 如果可选的第三个参数 `strict` 为 **TRUE**，则 `array_search()` 将在 `haystack` 中检查*完全相同*的元素。 这意味着同样严格比较 `haystack`里 `needle` 的 类型，并且对象需是同一个实例。

```php
$array = [0 => 'blue', 1 => 'red', 2 => 'green', 3 => 'red'];
$key = array_search('green', $array); // $key = 2;
```

- `array_shift ( array &$array ) : mixed — 将数组开头的单元移出数组`

> ###### 参数
>
> `array`
>
>   输入的数组。
>
> ###### 返回值
>
> 返回移出的值，如果 `array` 为 空或不是一个数组则返回 **NULL**。

```php
$stack = ["orange", "banana", "apple", "raspberry"];
$result = array_shift($stack);//$stack=["banana","apple","raspberry"]；$result=["orange"];
```

- `array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] ) : array — 从数组中取出一段`

> ###### 参数
>
> `array`
>
> 输入的数组。
>
> `offset`
>
> 如果 `offset` 非负，则序列将从 `array` 中的此偏移量开始。如果 `offset` 为负，则序列将从 `array` 中距离末端这么远的地方开始。
>
> `length`
>
> 如果给出了 `length` 并且为正，则序列中将具有这么多的单元。如果给出了 `length` 并且为负，则序列将终止在距离数组末端这么远的地方。如果省略，则序列将从 `offset` 开始一直到 `array` 的末端。
>
> `preserve_keys`
>
> 注意 `array_slice()` 默认会重新排序并重置数组的数字索引。你可以通过将 `preserve_keys` 设为 **TRUE** 来改变此行为。
>
> ###### 返回值
>
> 返回其中一段。 如果 offset 参数大于 array 尺寸，就会返回空的 array。

```php
$input = ["a", "b", "c", "d", "e"];

array_slice($input, 2);      		// ["c", "d","e"]
array_slice($input, -2, 1);  		// ["d"]
array_slice($input, 0, 3);   		// ["a", "b","c"]
array_slice($input, 2, -1);			// ["c","d"]
array_slice($input, 2, -1, true);	//  [2=>"c", 3=>"d"]
```

#### 字符串函数

- addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符
- addslashes — 使用反斜线引用字符串
- bin2hex — 函数把包含数据的二进制字符串转换为十六进制值
- chop — rtrim 的别名
- chr — 返回指定的字符
- chunk_split — 将字符串分割成小块
- convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种
- convert_uudecode — 解码一个 uuencode 编码的字符串
- convert_uuencode — 使用 uuencode 编码一个字符串
- count_chars — 返回字符串所用字符的信息
- crc32 — 计算一个字符串的 crc32 多项式
- crypt — 单向字符串散列
- echo — 输出一个或多个字符串
- explode — 使用一个字符串分割另一个字符串
- fprintf — 将格式化后的字符串写入到流
- get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表
- hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）
- hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符
- hex2bin — 转换十六进制字符串为二进制字符串
- html_entity_decode — Convert HTML entities to their corresponding characters
- htmlentities — 将字符转换为 HTML 转义字符
- htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符
- htmlspecialchars — 将特殊字符转换为 HTML 实体
- implode — 将一个一维数组的值转化为字符串
- join — 别名 implode
- lcfirst — 使一个字符串的第一个字符小写
- levenshtein — 计算两个字符串之间的编辑距离
- localeconv — Get numeric formatting information
- ltrim — 删除字符串开头的空白字符（或其他字符）
- md5_file — 计算指定文件的 MD5 散列值
- md5 — 计算字符串的 MD5 散列值
- metaphone — Calculate the metaphone key of a string
- money_format — 将数字格式化成货币字符串
- nl_langinfo — Query language and locale information
- nl2br — 在字符串所有新行之前插入 HTML 换行标记
- number_format — 以千位分隔符方式格式化一个数字
- ord — 转换字符串第一个字节为 0-255 之间的值
- parse_str — 将字符串解析成多个变量
- print — 输出字符串
- printf — 输出格式化字符串
- quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串
- quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串
- quotemeta — 转义元字符集
- rtrim — 删除字符串末端的空白字符（或者其他字符）
- setlocale — 设置地区信息
- sha1_file — 计算文件的 sha1 散列值
- sha1 — 计算字符串的 sha1 散列值
- similar_text — 计算两个字符串的相似度
- soundex — Calculate the soundex key of a string
- sprintf — Return a formatted string
- sscanf — 根据指定格式解析输入的字符
- str_getcsv — 解析 CSV 字符串为一个数组
- str_ireplace — str_replace 的忽略大小写版本
- str_pad — 使用另一个字符串填充字符串为指定长度
- str_repeat — 重复一个字符串
- str_replace — 子字符串替换
- str_rot13 — 对字符串执行 ROT13 转换
- str_shuffle — 随机打乱一个字符串
- str_split — 将字符串转换为数组
- str_word_count — 返回字符串中单词的使用情况
- strcasecmp — 二进制安全比较字符串（不区分大小写）
- strchr — 别名 strstr
- strcmp — 二进制安全字符串比较
- strcoll — 基于区域设置的字符串比较
- strcspn — 获取不匹配遮罩的起始子字符串的长度
- strip_tags — 从字符串中去除 HTML 和 PHP 标记
- stripcslashes — 反引用一个使用 addcslashes 转义的字符串
- stripos — 查找字符串首次出现的位置（不区分大小写）
- stripslashes — 反引用一个引用字符串
- stristr — strstr 函数的忽略大小写版本
- strlen — 获取字符串长度
- strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）
- strnatcmp — 使用自然排序算法比较字符串
- strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）
- strncmp — 二进制安全比较字符串开头的若干个字符
- strpbrk — 在字符串中查找一组字符的任何一个字符
- strpos — 查找字符串首次出现的位置
- strrchr — 查找指定字符在字符串中的最后一次出现
- strrev — 反转字符串
- strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）
- strrpos — 计算指定字符串在目标字符串中最后一次出现的位置
- strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。
- strstr — 查找字符串的首次出现
- strtok — 标记分割字符串
- strtolower — 将字符串转化为小写
- strtoupper — 将字符串转化为大写
- strtr — 转换指定字符
- substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）
- substr_count — 计算字串出现的次数
- substr_replace — 替换字符串的子串
- substr — 返回字符串的子串
- trim — 去除字符串首尾处的空白字符（或者其他字符）
- ucfirst — 将字符串的首字母转换为大写
- ucwords — 将字符串中每个单词的首字母转换为大写
- vfprintf — 将格式化字符串写入流
- vprintf — 输出格式化字符串
- vsprintf — 返回格式化字符串
- wordwrap — 打断字符串为指定数量的字串

#### 错误处理

- `error_get_last ( void ) : array — 获取最后发生的错误`
- `error_log ( string `$message` [, int `$message_type` = 0 [, string `$destination` [, string `$extra_headers` ]]] ) : bool — 发送错误信息到某个地方  ▲`（将日志保存记录到文件中，参照ThinkPHP5的日志驱动的底层代码）
- `error_reporting ([ int `$level` ] ) : int — 设置应该报告何种 PHP 错误`
- `set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] ) : mixed — 设置用户自定义的错误处理函数`
- `trigger_error ( string `$error_msg` [, int `$error_type` = E_USER_NOTICE ] ) : bool — 产生一个用户级别的 error/warning/notice 信息`

#### 文件系统函数

- `file_exists ( string `$filename` ) : bool — 检查文件或目录是否存在`

> ###### 参数
>
> `filename`
>
> 文件或目录的路径
>
> ###### 返回值
>
> 如果由 `filename` 指定的文件或目录存在则返回 **TRUE**，否则返回 **FALSE**。
>
> ###### 注释
>
>  失败时抛出**E_WARNING**警告。
>
> 此函数的结果会被缓存。

```php

```



- `file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] ) : string — 将整个文件读入一个字符串`

>##### 参数
>
>
>
>###### 返回值
>
>
>
>###### 注释
>
> 

```php

```



- `file_put_contents ( string `$filename` , [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) `$data` [, int `$flags` = 0 [, resource `$context` ]] ) : int — 将一个字符串写入文件`

> ##### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
>  

```php

```

- `file ( string `$filename` [, int `$flags` = 0 [, resource `$context` ]] ) : array — 把整个文件读入一个数组中`

> ##### 参数
>
> 
>
> ###### 返回值
>
> 
>
> ###### 注释
>
>  

```php

```

- `is_dir ( string `$filename` ) : bool — 判断给定文件名是否是一个目录`

> ##### 参数
>
> `filename`
>
> 如果文件名存在并且为目录则返回 **TRUE**。
>
> ###### 返回值
>
> 如果文件名存在，并且是个目录，返回 **TRUE**，否则返回**FALSE**。
>
> ###### 注释
>
>  失败时抛出**E_WARNING**警告。
>
> 此函数的结果会被缓存。

```php

```

- `is_file ( string `$filename` ) : bool — 判断给定文件名是否为一个正常的文件`

> ##### 参数
>
> `filename`
>
> 文件的路径。
>
> ###### 返回值
>
> 如果文件存在且为正常的文件则返回 **TRUE**，否则返回 **FALSE**。
>
> ###### 注释
>
>  失败时抛出**E_WARNING**警告。

```php

```

- `unlink ( string `$filename` [, resource `$context` ] ) : bool — 删除文件`

> ##### 参数
>
> `filename`
>
> 文件的路径。
>
> `context`
>
> 成功时返回 **TRUE**， 或者在失败时返回 **FALSE**。
>
> ###### 返回值
>
> 
>
> ###### 注释
>
>  

```php

```

- `touch ( string $filename [, int $time = time() [, int $atime ]] ) : bool — 设定文件的访问和修改时间`

> ##### 参数
>
> `filename`
>
> 要设定的文件名。
>
> `time`
>
> 要设定的时间。如果没有提供参数 `time` 则会使用当前系统的时间。
>
> `atime`
>
> 如果给出了这个参数，则给定文件的访问时间会被设为 `atime`，否则会设置 为`time`。如果没有给出这两个参数，则使用当前系统时间。
>
> ###### 返回值
>
> 成功时返回 **TRUE**， 或者在失败时返回 **FALSE**。
>
> ###### 注释
>
>  

```php

```

- `tmpfile ( void ) : resource — 建立一个临时文件`

> ##### 参数
>
> 
>
> ###### 返回值
>
> 返回一个与 `fopen()` 所打开返回类似的新文件句柄， 或者在失败时返回 **FALSE**.
>
> ###### 注释
>
>  以读写（w+）模式建立一个具有唯一文件名的临时文件，返回一个文件句柄。
>
> 文件会在关闭后（用 `fclose()`）自动被删除，或当脚本结束后。
>
> 详细信息请参考系统手册中的 *tmpfile(3)* 函数，以及 stdio.h 头文件。

```php
$temp = tmpfile();
fwrite($temp, "writing to tempfile");
fseek($temp, 0);
echo fread($temp, 1024);
fclose($temp); // this removes the file
```

- `tempnam ( string $dir , string $prefix ) : string — 建立一个具有唯一文件名的文件`

> ##### 参数
>
> `dir`
>
> The directory where the temporary filename will be created.
>
> `prefix`
>
> 产生临时文件的前缀。
>
> ###### 返回值
>
> 返回新的临时文件名，出错返回 **FALSE**。
>
> ###### 注释
>
>  在指定目录中建立一个具有唯一文件名的文件。如果该目录不存在，**tempnam()** 会在系统临时目录中生成一个文件，并返回其文件名。	

```php

```

- `stat ( string `$filename` ) : array — 给出文件的信息`

> ##### 参数
>
> `filename`
>
> 文件的路径。
>
> ###### 返回值
>
> 数组或`FALSE`
>
> ###### 注释
>
>  错误时会产生 **E_WARNING** 级别的错误。
>
>  此函数的结果会被缓存。

```php
print_r(stat($filename));
```

- `rmdir ( string `$dirname` [, resource `$context` ] ) : bool — 删除目录`

> ##### 参数
>
> `dirname`
>
> 目录的路径。
>
> `context`
>
> ###### 返回值
>
> 成功时返回 **TRUE**， 或者在失败时返回 **FALSE**。
>
> ###### 注释
>
>  尝试删除 `dirname` 所指定的目录。 该目录必须是空的，而且要有相应的权限。 失败时会产生一个 **E_WARNING** 级别的错误。

```php
rmdir('examples');
```

- `rename ( string `$oldname` , string `$newname` [, resource `$context` ] ) : bool — 重命名一个文件或目录`

> ##### 参数
>
> `oldname`
>
> 用于 `oldname` 中的封装协议*必须*和用于 `newname` 中的相匹配
>
> `newname`
>
> 新的名字。
>
> `context`
>
> ###### 返回值
>
> 成功时返回 **TRUE**， 或者在失败时返回 **FALSE**。
>
> ###### 注释
>
>  

```php

```

- `realpath ( string `$path` ) : string — 返回规范化的绝对路径名`

> ##### 参数
>
> `path`
>
> 要检查的路径。
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```

- `readfile ( string `$filename` [, bool `$use_include_path` = false [, resource `$context` ]] ) : int - 读取文件并写入到输出缓冲。`

> ##### 参数
>
> `filename`
>
> 要读取的文件名。
>
> `use_include_path`
>
> 
>
> `context`
>
> 
>
> ###### 返回值
>
> 返回从文件中读入的字节数。如果出错返回 **FALSE** 并且除非是以 @**readfile()** 形式调用，否则会显示错误信息。
>
> ###### 注释
>
> 

```php

```

- `pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : mixed — 返回文件路径的信息`

> ##### 参数
>
> `path`
>
> 要解析的路径。
>
> `options`
>
> 如果指定了，将会返回指定元素；它们包括：**PATHINFO_DIRNAME**，**PATHINFO_BASENAME** 和 **PATHINFO_EXTENSION** 或 **PATHINFO_FILENAME**。
>
> 如果没有指定 `options` 默认是返回全部的单元。
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```

- `move_uploaded_file ( string `$filename` , string `$destination` ) : bool — 将上传的文件移动到新位置`

> ##### 参数
>
> `filename`
>
> 上传的文件的文件名。
>
> `destination`
>
> 移动文件到这个位置。
>
> ###### 返回值
>
> 成功时返回 **TRUE**。
>
> 如果 `filename` 不是合法的上传文件，不会出现任何操作，**move_uploaded_file()** 将返回 **FALSE**。
>
> 如果 `filename` 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，**move_uploaded_file()** 将返回 **FALSE**。此外还会发出一条警告。
>
> ###### 注释
>
> 

```php

```

- `mkdir ( string `$pathname` [, int `$mode` = 0777 [, bool `$recursive` = false [, resource `$context` ]]] ) : bool — 新建目录`

> ##### 参数
>
> `pathname`
>
> 目录的路径。
>
> `mode`
>
> 默认的 mode 是 0777，意味着最大可能的访问权。
>
> `recursive`
>
> 允许递归创建由 `pathname` 所指定的多级嵌套目录。
>
> ###### 返回值
>
> 成功时返回 **TRUE**， 或者在失败时返回 **FALSE**。
>
> ###### 注释
>
> 

```php

```

- `is_writable ( string `$filename` ) : bool — 判断给定的文件名是否可写`

> ##### 参数
>
> `filename`
>
> 要检查的文件名称。
>
> ###### 返回值
>
> 如果文件 `filename` 存在并且可写则返回 **TRUE**。失败时抛出**E_WARNING**警告。
>
> ###### 注释
>
> 此函数的结果会被缓存。

```php

```

- `is_uploaded_file ( string `$filename` ) : bool — 判断文件是否是通过 HTTP POST 上传的`

> ##### 参数
>
> `filename`
>
> 要检查的文件名。
>
> ###### 返回值
>
> 如果 `filename` 所给出的文件是通过 HTTP POST 上传的则返回 **TRUE**。这可以用来确保恶意的用户无法欺骗脚本去访问本不能访问的文件， 或者在失败时返回 **FALSE**。
>
> ###### 注释
>
> 必段指定类似于`$_FILES['userfile']['tmp_name']` 的变量

```php

```

- `is_readable ( string `$filename` ) : bool — 判断给定文件名是否可读`

> ##### 参数
>
> `filename`
>
> 文件的路径。
>
> ###### 返回值
>
> 如果由 `filename` 指定的文件或目录存在并且可读则返回 **TRUE**，否则返回 **FALSE**。失败时抛出**E_WARNING**警告。对于目录这个函数可能会返回 **TRUE**。
>
> ###### 注释
>
> 

```php

```

- `is_file ( string `$filename` ) : bool — 判断给定文件名是否为一个正常的文件`

> ##### 参数
>
> `filename`
>
> 文件的路径。
>
> ###### 返回值
>
> 如果文件存在且为正常的文件则返回 **TRUE**，否则返回 **FALSE**。失败时抛出**E_WARNING**警告。
>
> ###### 注释
>
> 此函数的结果会被缓存。

```php

```

- `is_dir ( string `$filename` ) : bool — 判断给定文件名是否是一个目录`

> ##### 参数
>
> `filename`
>
> 如果文件名存在并且为目录则返回 **TRUE**。如果 `filename` 是一个相对路径，则按照当前工作目录检查其相对路径。
>
> ###### 返回值
>
> 如果文件名存在，并且是个目录，返回 **TRUE**，否则返回**FALSE**。失败时抛出**E_WARNING**警告。
>
> ###### 注释
>
> 此函数的结果会被缓存。

```php

```

- `fwrite ( resource $handle , string $string [, int $length ] ) : int — 写入文件（可安全用于二进制文件）`

> ##### 参数
>
> `handle`
> 文件系统指针，是典型地由 fopen() 创建的 resource(资源)。
>
> `string`
> The string that is to be written.
>
> `length`
> 如果指定了 length，当写入了 length 个字节或者写完了 string 以后，写入就会停止，视乎先碰到哪种情况。
>
> ###### 返回值
>
> `fwrite()` 返回写入的字符数，出现错误时则返回 **FALSE** 。
>
> ###### 注释
>
> 

```php

```

- ``

> ##### 参数
>
> `
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```

- ``

> ##### 参数
>
> `
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```

```php
basename — 返回路径中的文件名部分
chgrp — 改变文件所属的组
chmod — 改变文件模式
chown — 改变文件的所有者
clearstatcache — 清除文件状态缓存
copy — 拷贝文件
delete — 参见 unlink 或 unset
dirname — 返回路径中的目录部分
disk_free_space — 返回目录中的可用空间
disk_total_space — 返回一个目录的磁盘总大小
diskfreespace — disk_free_space 的别名
fclose — 关闭一个已打开的文件指针
feof — 测试文件指针是否到了文件结束的位置
fflush — 将缓冲内容输出到文件
fgetc — 从文件指针中读取字符
fgetcsv — 从文件指针中读入一行并解析 CSV 字段
fgets — 从文件指针中读取一行
fgetss — 从文件指针中读取一行并过滤掉 HTML 标记
file_exists — 检查文件或目录是否存在
file_get_contents — 将整个文件读入一个字符串
file_put_contents — 将一个字符串写入文件
file — 把整个文件读入一个数组中
fileatime — 取得文件的上次访问时间
filectime — 取得文件的 inode 修改时间
filegroup — 取得文件的组
fileinode — 取得文件的 inode
filemtime — 取得文件修改时间
fileowner — 取得文件的所有者
fileperms — 取得文件的权限
filesize — 取得文件大小
filetype — 取得文件类型
flock — 轻便的咨询文件锁定
fnmatch — 用模式匹配文件名
fopen — 打开文件或者 URL
fpassthru — 输出文件指针处的所有剩余数据
fputcsv — 将行格式化为 CSV 并写入文件指针
fputs — fwrite 的别名
fread — 读取文件（可安全用于二进制文件）
fscanf — 从文件中格式化输入
fseek — 在文件指针中定位
fstat — 通过已打开的文件指针取得文件信息
ftell — 返回文件指针读/写的位置
ftruncate — 将文件截断到给定的长度
fwrite — 写入文件（可安全用于二进制文件）
glob — 寻找与模式匹配的文件路径
is_dir — 判断给定文件名是否是一个目录
is_executable — 判断给定文件名是否可执行
is_file — 判断给定文件名是否为一个正常的文件
is_link — 判断给定文件名是否为一个符号连接
is_readable — 判断给定文件名是否可读
is_uploaded_file — 判断文件是否是通过 HTTP POST 上传的
is_writable — 判断给定的文件名是否可写
is_writeable — is_writable 的别名
lchgrp — 修改符号链接的所有组
lchown — 修改符号链接的所有者
link — 建立一个硬连接
linkinfo — 获取一个连接的信息
lstat — 给出一个文件或符号连接的信息
mkdir — 新建目录
move_uploaded_file — 将上传的文件移动到新位置
parse_ini_file — 解析一个配置文件
parse_ini_string — 解析配置字符串
pathinfo — 返回文件路径的信息
pclose — 关闭进程文件指针
popen — 打开进程文件指针
readfile — 输出文件
readlink — 返回符号连接指向的目标
realpath_cache_get — 获取真实目录缓存的详情
realpath_cache_size — 获取真实路径缓冲区的大小
realpath — 返回规范化的绝对路径名
rename — 重命名一个文件或目录
rewind — 倒回文件指针的位置
rmdir — 删除目录
set_file_buffer — stream_set_write_buffer 的别名
stat — 给出文件的信息
symlink — 建立符号连接
tempnam — 建立一个具有唯一文件名的文件
tmpfile — 建立一个临时文件
touch — 设定文件的访问和修改时间
umask — 改变当前的 umask
unlink — 删除文件
```

#### 密码散列算法函数

- `password_hash ( string `$password` , int `$algo` [, array `$options` ] ) : string — 创建密码的散列（hash）`

> ##### 参数
>
> `
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> **password_hash()** 使用足够强度的单向散列算法创建密码的散列（hash）。 **password_hash()** 兼容 crypt()。 所以， crypt() 创建的密码散列也可用于 **password_hash()**。

```php

```

- `password_verify ( string `$password` , string `$hash` ) : bool — 验证密码是否和散列值匹配`

> ##### 参数
>
> `password`
>
> 用户的密码。
>
> `hash`
>
> 一个由 `password_hash()` 创建的散列值。
>
> ###### 返回值
>
> 如果密码和散列值匹配则返回 **TRUE**，否则返回 **FALSE** 。
>
> ###### 注释
>
> 

```php

```

- ``

> ##### 参数
>
> `
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```

- ``

> ##### 参数
>
> `
>
> ###### 返回值
>
> 
>
> ###### 注释
>
> 

```php

```



#### 类

###### The SplFileObject class

## MySQL数据库

[MySQL手册](<http://www.searchdoc.cn/rdbms/mysql/dev.mysql.com/doc/refman/5.7/en/index.com.coder114.cn.html>)



## Redis缓存

[Redis中文网](<http://www.redis.cn/>)

## Linux基础
## Linux高级
## Laravel

## Yii2

## 正则表达式

#### 正则

## 计算机基础知识

## Markdown语法

## Vue

## Flex布局



## 小程序

## WebSocket

## Swoole

[文档](Swoole<https://wiki.swoole.com/wiki/>)

## ThinkPHP

- 疑问一：使用`realpath_cache_get()`和`realpath_cache_size()` 获取真实目录缓存的详情,这些文件的作用是什么？使用`realpath_cache_get()`和`realpath_cache_size()` 获取的数据是什么意思？



- 使用`file_put_contents`保存客户端上传的格式为base64编码的图片

```php
$img = 'data:image/png;base64,iVBORw0KG...';
$start = strpos($img,',');
$img = substr($img,$start+1);
$img = str_replace(' ', '+', $img);
$data = base64_decode($img);
$fileName = $path .uniqid(). '.png';
file_put_contents($fileName, $data);
```

- 使用File处理上传文件

```php
$filename = $_FILES['file'];
$destination = realpath((new App())->getAppPath() . '../uploads/image');
$fileClass = new File($filename['tmp_name']);
$fileClass->setUploadInfo($filename)->move($destination);
```

## HTTP客户端

1. GuzzleHttp
2. file_get_contents
3. curl

## JavaScript

